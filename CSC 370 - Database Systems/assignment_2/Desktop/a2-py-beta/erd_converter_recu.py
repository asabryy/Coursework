from multiprocessing import connection
from attr import attr

from matplotlib.pyplot import table
from erd import *
from table import *

# This function converts an ERD object into a Database object
# The Database object should correspond to a fully correct implementation
# of the ERD, including both data structure and constraints, such that the
# CREATE TABLE statements generated by the Database object will populate an
# empty MySQL database to exactly implement the conceptual design communicated
# by the ERD.
#
# @TODO: Implement me!

def create_table(name, attr, pkey, fkeys):
    for f in fkeys:
        attr += f[0]
    return Table(name, set(attr), set(pkey), set(fkeys))

def add_fkeys( ent ):
    return (tuple(set(ent.primary_key)), ent.name, tuple(set(ent.primary_key)))

def get_fkeys(rel, erd ):
    fkeys = []
    e_relation = []
    if type(rel) == EntitySet:
        for r in rel.connections:
            for e in erd.entity_sets:
                for c in e.connections:
                    #print(r, "with ", c)
                    if (r[0] == c[0]) and (rel.name != e.name):
                        if (r[1] == Multiplicity.MANY) and (c[1] == Multiplicity.ONE):
                            fkeys.append(add_fkeys(e))
                            e_relation.append(r[0]) 

    elif type(rel) == Relationship:
        for e in erd.entity_sets:
            for c in e.connections:
                if c[0] == rel.name and (c[1] == Multiplicity.MANY):
                    e_relation.append(e)
        if len(e_relation) > 1:
            for i in e_relation:
                fkeys.append(add_fkeys(i))
    
    return fkeys, e_relation

def get_weak(rel, erd):
    fkeys = []
    for e in erd.entity_sets:
        for c in e.connections:
            if c[0] in rel.supporting_relations:
                fkeys.append(add_fkeys(e))
                rel.primary_key += e.primary_key
    return fkeys

def get_child(rel, erd):
    fkeys = []
    for e in erd.entity_sets:
        if e.name in rel.parents:
            fkeys.append(add_fkeys(e))
            rel.primary_key += e.primary_key
    return fkeys

def create_rel(rel, e_list, fkeys):
    attr = rel.attributes
    pkeys = rel.primary_key
    for e in e_list:
        attr += e.primary_key
        pkeys += e.primary_key
    
    return create_table(rel.name, attr, pkeys, fkeys)

def create_entity(ent, r_list, fkeys, erd):
    attr = ent.attributes                   #FIX THIS FOR THE BONUS STUFF!
    for r in r_list:
        for rr in erd.relationships:
            if rr.name == r:
                attr += rr.attributes
                ent.primary_key += rr.primary_key
    return create_table(ent.name, attr, ent.primary_key, fkeys)

def convert_helper( erd, tracker ):
    result = []
    for e in erd.entity_sets:
        fkeys, r_rel = get_fkeys(e, erd)
        fkeys += get_weak(e, erd)
        fkeys += get_child(e, erd)
        result.append(create_entity(e, r_rel, fkeys, erd,))

    for r in erd.relationships:
        fkeys, e_rel = get_fkeys(r, erd)
        if len(fkeys) != 0:
            result.append(create_rel(r, e_rel, fkeys))
    
    if len(tracker) > 0:
        if tracker[len(tracker)-1] == Database(result):
            print(Database(result).tables)
            return Database(result)
        else:
            tracker.append(Database(result))
            return convert_helper(erd ,tracker)
    else:
        tracker.append(Database(result))
        return convert_helper(erd, tracker)

def convert_to_table( erd ):
    tracker = []
    return convert_helper(erd, tracker)

def main():
    convert_to_table(ERD( \
            [Relationship('PlaysFor',['start_date','end_date'],['start_date',])], \
            [EntitySet('Player', ['player_id', 'player_name'], ['player_id',], [('PlaysFor', Multiplicity.MANY)], [], []), \
            EntitySet('Team', ['team_name', 'city', 'league'], ['team_name', 'city'], \
                [('PlaysFor', Multiplicity.MANY)], [], [])]))
    pass

if __name__ == "__main__":
    main()
