#!/usr/bin/env python3
"""
  Name:     Ahmed Ahmed 
  Student#: V00947456 
  Course:   SENG 265 
  Assignment 4
"""
import sys
from datetime import datetime
import datetime as dt
import re

class event:
    """event class used to make and store event obj information after 
    parsing from ics file.
    """
    
    def __init__(self, startD=None, endD=None, summary=None, location="", rule=None):
        """event class constructor, sets all parameters to None.
        """
        self.startD = startD
        self.endD = endD
        self.summary = summary
        self.location = location
        self.rule = rule
    
    def set_event(self, startD, endD, summary, location, rule):
        """event class constructor, if all attributes are given and known.
        primarly used to copy event information to a new event. 
        """
        self.startD = startD
        self.endD = endD
        self.summary = summary
        self.location = location
        self.rule = rule
    
    def set_start(self, startD):
        """DTSTART datetime setter
        """
        self.startD = startD
    
    def set_end(self, endD):
        """DTEND datetime setter
        """
        self.endD = endD
    
    def set_summary(self, summary):
        """SUMMARY information setter
        """
        self.summary = summary
    
    def set_location(self, location):
        """LOCATION information setter
        """
        self.location = location

    def set_rule(self, rule):
        """RRULE information setter
        """
        self.rule = rule

    def create_rules(self, events):
        """
        Checks if an event contains a repeating rule, if so 
        it genrates all the repeating events until end date and
        adds them to list of events
        """
        #add 1 week to start and end date
        tempstart = self.startD + dt.timedelta(days = 7)
        tempend = self.endD + dt.timedelta(days = 7)

        if(self.rule):
            while tempstart <= self.rule:
                tempEvent = event()
                #copies orginal event content to repating event
                tempEvent.set_event(tempstart, tempend, self.summary, self.location, self.rule)
                #increment by 1 week inside loop
                tempstart = tempstart + dt.timedelta(days = 7)
                tempend = tempend + dt.timedelta(days = 7)
                #add new events to orginal list
                events.append(tempEvent)


class process_cal:
    """ outputs the events from the calendar file into a more readable form
    """
    
    def __init__(self, filename):
        """sets filename to filenmae parameter.
        """
        self.filename = filename
    
    def get_events_for_day(self, in_date):
        """method called to retrive requested information, and return formated
        string
        """
        output = None
        #lines array assigned all lines in file
        lines = self.read_file()
        #events, list of event objects, generated by scan_events
        events = self.scan_events(lines)
        #final output string formated by get_output method
        output = self.get_output(events, in_date)
        return output

    def read_file(self):
        """ 
        Reades stored filename, opens the file and iterates 
        through and copies every line to an array. 
        Returns line array
        """
        lines = []
        f = open(self.filename)
        for l in f:
            #add line to array
            lines.append(l)
        f.close()
        return lines
    
    def get_output(self, events, in_date):
        """Takes events list and requested date to get events for. 
        Sorts events in order and creates string if events found on
        input date reqired format for final output. 
        Returns output (formated string)    
        """
        events.sort(key=lambda d: d.startD)
        string = """"""
        #foundday variable used to check if day found or not
        foundday = 0
        #count to manage line space before each day in output
        count = 0
        for e in events:
            #formating header for day that has events
            if e.startD.date() == in_date.date() and foundday == 0:
                #create header string for day to be printed - day: <month text><day>,<year>(<day of week>)
                header = e.startD.strftime("%B %d, %Y (%a)")
                string += header +"\n"
                 #add underline matching the size of header string
                underline = ('-' * len(header))
                underline += "\n"
                string += underline
                foundday = 1
            #formatting events based on information provided
            if e.startD.date() == in_date.date() and foundday == 1:
                if(count > 0 ):
                    string += "\n"
                strEvent ="{} to {} {} ".format(e.startD.strftime("%l:%M %p"), e.endD.strftime("%l:%M %p:"), e.summary)
                string += strEvent
                strLocation = "{{{{{}}}}}".format(e.location)
                string += strLocation
                count += 1
        return string

    def regex_method(self, l, string):
        """ takes a string and line as parameters and checks for a pattern 
        within the line using regex, using the string as the label. If its a
        date then its parsed then converted and returned as datetime format.
        """
        pattern1 = re.compile(r"%s:.*(\d\d\d\d\d\d\d\dT\d\d\d\d\d\d).*"%string)
        pattern2 = re.compile(r"%s:(.*)"%string)
        m = pattern1.search(l)
        m2 = pattern2.search(l)
        if m:
            return datetime.strptime(m.group(1), "%Y%m%dT%H%M%S")
        if m2:
            return m2.group(1)

    def scan_events(self, lines):
        """
        Iterates through every line from line array and detects event
        using "BEGIN:VEVENT" tag and creats new dictionary and stars parsing
        information based on label using regex_method() method. 
        Adds event to list of events once "END:VEVENT" parsed.
        """
        events = []
        tempEvent = event()
        for l in lines:
            #check begining of event entry
            if("BEGIN:VEVENT" in l):
                tempEvent = event()
            if(self.regex_method(l, "DTSTART")):
                tempEvent.set_start(self.regex_method(l, "DTSTART"))
            if(self.regex_method(l, "DTEND")):
                tempEvent.set_end(self.regex_method(l, "DTEND"))
            if(self.regex_method(l, "LOCATION")):
                tempEvent.set_location(self.regex_method(l, "LOCATION"))
            if(self.regex_method(l, "SUMMARY")):
                tempEvent.set_summary(self.regex_method(l, "SUMMARY"))
            if(self.regex_method(l, "RRULE")):
                tempEvent.set_rule(self.regex_method(l, "RRULE"))
            if("END:VEVENT" in l):
                #add event since "END:VEVENT" found
                events.append(tempEvent)
                #checks for and adds repeating rules
                tempEvent.create_rules(events)
        
        return events